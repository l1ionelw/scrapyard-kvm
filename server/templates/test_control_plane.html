<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Keyboard + Mouse WebSocket Client</title>
  <style>
    #mouseLockBtn { position: fixed; top: 12px; left: 12px; z-index: 9999; }
    #wsStatus {
      position: fixed;
      top: 12px;
      right: 12px;
      z-index: 9999;
      padding: 8px 16px;
      border-radius: 6px;
      font-family: monospace;
      font-weight: bold;
      font-size: 14px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
      transition: all 0.3s ease;
    }
    .ws-connecting {
      background-color: #ffa500;
      color: white;
      border: 2px solid #ff8c00;
    }
    .ws-connected {
      background-color: #4caf50;
      color: white;
      border: 2px solid #45a049;
    }
    .ws-disconnected {
      background-color: #f44336;
      color: white;
      border: 2px solid #da190b;
    }
    .ws-error {
      background-color: #9c27b0;
      color: white;
      border: 2px solid #7b1fa2;
      animation: pulse 1s infinite;
    }
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    #errorLog {
      position: fixed;
      bottom: 12px;
      right: 12px;
      z-index: 9999;
      background-color: rgba(244, 67, 54, 0.9);
      color: white;
      padding: 8px 12px;
      border-radius: 4px;
      font-family: monospace;
      font-size: 12px;
      max-width: 300px;
      display: none;
      box-shadow: 0 2px 8px rgba(0,0,0,0.2);
    }
  </style>
</head>
<body>
<button id="mouseLockBtn">Enable Mouse Capture</button>
<div id="wsStatus" class="ws-connecting">Connecting...</div>
<div id="errorLog"></div>
<script>
/* ---------------- HID map ---------------- */
const HIDCodeMap = {
  // Letters
  'KeyA':0x04,'KeyB':0x05,'KeyC':0x06,'KeyD':0x07,'KeyE':0x08,'KeyF':0x09,'KeyG':0x0A,'KeyH':0x0B,
  'KeyI':0x0C,'KeyJ':0x0D,'KeyK':0x0E,'KeyL':0x0F,'KeyM':0x10,'KeyN':0x11,'KeyO':0x12,'KeyP':0x13,
  'KeyQ':0x14,'KeyR':0x15,'KeyS':0x16,'KeyT':0x17,'KeyU':0x18,'KeyV':0x19,'KeyW':0x1A,'KeyX':0x1B,
  'KeyY':0x1C,'KeyZ':0x1D,
  // Numbers (top row)
  'Digit1':0x1E,'Digit2':0x1F,'Digit3':0x20,'Digit4':0x21,'Digit5':0x22,'Digit6':0x23,'Digit7':0x24,'Digit8':0x25,'Digit9':0x26,'Digit0':0x27,
  // Enter, Escape, Backspace, Tab, Space
  'Enter':0x28,'Escape':0x29,'Backspace':0x2A,'Tab':0x2B,'Space':0x2C,
  // Symbols
  'Minus':0x2D,'Equal':0x2E,'BracketLeft':0x2F,'BracketRight':0x30,'Backslash':0x31,'Semicolon':0x33,
  'Quote':0x34,'Backquote':0x35,'Comma':0x36,'Period':0x37,'Slash':0x38,
  // Function keys
  'F1':0x3A,'F2':0x3B,'F3':0x3C,'F4':0x3D,'F5':0x3E,'F6':0x3F,'F7':0x40,'F8':0x41,'F9':0x42,'F10':0x43,'F11':0x44,'F12':0x45,
  // Arrows + Delete
  'ArrowRight':0x4F,'ArrowLeft':0x50,'ArrowDown':0x51,'ArrowUp':0x52,'Delete':0x4C,
  // Modifier bitmasks (your server expects these)
  'ControlLeft':0x01,'ShiftLeft':0x02,'AltLeft':0x04,'MetaLeft':0x08,
  'ControlRight':0x10,'ShiftRight':0x20,'AltRight':0x40,'MetaRight':0x80,
  // Numpad
  'Numpad0':0x62,'Numpad1':0x59,'Numpad2':0x5A,'Numpad3':0x5B,'Numpad4':0x5C,'Numpad5':0x5D,'Numpad6':0x5E,'Numpad7':0x5F,'Numpad8':0x60,'Numpad9':0x61,
  'NumpadAdd':0x57,'NumpadSubtract':0x56,'NumpadMultiply':0x55,'NumpadDivide':0x54,'NumpadDecimal':0x63,'NumpadEnter':0x58
};

/* ---------------- WebSocket with Status Display ---------------- */
const wsStatusEl = document.getElementById('wsStatus');
const errorLogEl = document.getElementById('errorLog');
let errorTimeout = null;

function updateWSStatus(status, message) {
  wsStatusEl.className = `ws-${status}`;
  wsStatusEl.textContent = message;
}

function showError(message) {
  errorLogEl.textContent = message;
  errorLogEl.style.display = 'block';
  
  // Clear any existing timeout
  if (errorTimeout) {
    clearTimeout(errorTimeout);
  }
  
  // Hide error after 5 seconds
  errorTimeout = setTimeout(() => {
    errorLogEl.style.display = 'none';
  }, 5000);
}

const ws = new WebSocket("ws://192.168.1.29:5000");

ws.onopen = () => {
  console.log("Connected to Pi HID server");
  updateWSStatus('connected', 'ðŸŸ¢ Connected');
};

ws.onmessage = (event) => {
  try { console.log("Server response:", JSON.parse(event.data)); }
  catch { console.log("Server response (raw):", event.data); }
};

ws.onerror = (e) => {
  console.error("WS error:", e);
  updateWSStatus('error', 'ðŸ”´ Connection Error');
  showError('WebSocket connection error occurred');
};

ws.onclose = (event) => {
  console.log("WS closed", event.code, event.reason);
  updateWSStatus('disconnected', 'ðŸ”´ Disconnected');
  if (event.code !== 1000) { // Not a normal closure
    showError(`Connection lost (Code: ${event.code})`);
  }
};

function sendJSON(obj){
  if (ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify(obj));
  } else {
    console.warn("WS not open; dropping", obj);
    updateWSStatus('error', 'ðŸŸ¡ Send Failed');
    showError(`Cannot send: WebSocket is ${ws.readyState === WebSocket.CONNECTING ? 'connecting' : 'closed'}`);
  }
}

/* ============== KEYBOARD (FIXED) ============== */
let currentModifiers = new Set();   // currently held modifier HID codes
let pressedKeys = new Set();        // track all currently pressed keys

const modifierCodes = new Set([
  "ControlLeft","ControlRight","ShiftLeft","ShiftRight","AltLeft","AltRight","MetaLeft","MetaRight"
]);

function getModifierBitmask() {
  // Convert current modifiers to array for server
  return Array.from(currentModifiers);
}

function sendKeyStroke(normalKey) {
  sendJSON({
    type: "KEYBOARD",
    action: "PRESS",
    key: normalKey,                 
    modifiers: getModifierBitmask()
  });
}

document.addEventListener("keydown", (event) => {
  if (event.repeat) return; // Ignore key repeats
  
  const code = event.code;
  const hid = HIDCodeMap[code];
  if (hid === undefined) return;

  // Prevent duplicate processing
  if (pressedKeys.has(code)) return;
  pressedKeys.add(code);

  if (modifierCodes.has(code)) {
    currentModifiers.add(hid);
  } else {
    // Send keystroke immediately on keydown for normal keys
    sendKeyStroke(hid);
  }
  
  event.preventDefault();
}, { capture: true });

document.addEventListener("keyup", (event) => {
  const code = event.code;
  const hid = HIDCodeMap[code];
  if (hid === undefined) return;

  // Remove from pressed keys tracking
  pressedKeys.delete(code);

  if (modifierCodes.has(code)) {
    currentModifiers.delete(hid);
  }
  
  event.preventDefault();
}, { capture: true });

/* ============== MOUSE (pointer lock) ============== */
const btn = document.getElementById("mouseLockBtn");
btn.addEventListener("click", () => {
  const el = document.body;
  try { el.requestPointerLock && el.requestPointerLock({ unadjustedMovement: true }); }
  catch { el.requestPointerLock && el.requestPointerLock(); }
});

function sendMousePayload(obj){ sendJSON(obj); }

/* ---- NEW: batching state for locked mouse movement ---- */
let moveBatchDX = 0;
let moveBatchDY = 0;
let moveBatchIntervalId = null;
const MOVE_BATCH_MS = 50;

function startMoveBatcher() {
  if (moveBatchIntervalId != null) return;
  moveBatchIntervalId = setInterval(() => {
    flushMoveBatch();
  }, MOVE_BATCH_MS);
}

function stopMoveBatcher() {
  if (moveBatchIntervalId != null) {
    clearInterval(moveBatchIntervalId);
    moveBatchIntervalId = null;
  }
}

function flushMoveBatch() {
  if (moveBatchDX !== 0 || moveBatchDY !== 0) {
    if (moveBatchDX > 126) {moveBatchDX = 126}
          if (moveBatchDX < -126) {moveBatchDX = -126}
          if (moveBatchDY > 126) {moveBatchDY = 126}
          if (moveBatchDY < -126) {moveBatchDY = -126}
    sendMousePayload({ type:"MOUSE", action:"MOVE", key: `${moveBatchDX}|${moveBatchDY}` });
    moveBatchDX = 0;
    moveBatchDY = 0;
  }
}

function onPointerLockChange() {
  const locked = (document.pointerLockElement === document.body);
  btn.style.display = locked ? "none" : "";
  if (locked) {
    attachMouseListeners();
    startMoveBatcher();
  } else {
    flushMoveBatch();
    stopMoveBatcher();
    detachMouseListeners();
  }
}
document.addEventListener("pointerlockchange", onPointerLockChange);
document.addEventListener("pointerlockerror", () => console.error("Pointer lock error"));

function onContextMenu(e){ e.preventDefault(); }

function onMouseMove(e){
  const dx = e.movementX || 0;
  const dy = e.movementY || 0;
  const locked = (document.pointerLockElement === document.body);

  if (locked) {
    moveBatchDX += dx;
    moveBatchDY += dy;

    // flush immediately if the accumulated delta would exceed Â±126
    if (moveBatchDX > 126 || moveBatchDX < -126 ||
        moveBatchDY > 126 || moveBatchDY < -126) {
          if (moveBatchDX > 126) {moveBatchDX = 126}
          if (moveBatchDX < -126) {moveBatchDX = -126}
          if (moveBatchDY > 126) {moveBatchDY = 126}
          if (moveBatchDY < -126) {moveBatchDY = -126}
      flushMoveBatch();
    }
  } else {
    if (dx || dy) sendMousePayload({ type:"MOUSE", action:"MOVE", key: `${dx}|${dy}` });
  }
  e.preventDefault();
}

function onMouseDown(e){
  if (e.button === 0) sendMousePayload({ type:"MOUSE", action:"CLICK", key:"LCLICK" });
  else if (e.button === 2) sendMousePayload({ type:"MOUSE", action:"CLICK", key:"RCLICK" });
  e.preventDefault();
}

function onWheel(e){
  const dir = e.deltaY > 0 ? 10 : -10;
  sendMousePayload({ type:"MOUSE", action:"SCROLL", key: String(dir) });
  e.preventDefault();
}

function attachMouseListeners(){
  window.addEventListener("mousemove", onMouseMove, true);
  window.addEventListener("mousedown", onMouseDown, true);
  window.addEventListener("contextmenu", onContextMenu, { capture:true });
  window.addEventListener("wheel", onWheel, { passive:false, capture:true });
}
function detachMouseListeners(){
  window.removeEventListener("mousemove", onMouseMove, true);
  window.removeEventListener("mousedown", onMouseDown, true);
  window.removeEventListener("contextmenu", onContextMenu, { capture:true });
  window.removeEventListener("wheel", onWheel, { capture:true });
}
</script>
</body>
</html>